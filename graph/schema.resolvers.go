package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"OzonTask/db"
	"OzonTask/graph/generated"
	"OzonTask/graph/model"
	"OzonTask/model/dbmodel"
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
)

func (r *commentResolver) ID(ctx context.Context, obj *model.Comment) (string, error) {
	return obj.ID.String(), nil
}

func (r *commentResolver) PostID(ctx context.Context, obj *model.Comment) (string, error) {
	return obj.PostID.String(), nil
}

func (r *commentResolver) ParentID(ctx context.Context, obj *model.Comment) (*string, error) {
	if obj.ParentID == nil {
		return nil, nil
	}
	parentStr := obj.ParentID.String()
	return &parentStr, nil
}

func (r *commentResolver) CreatedAt(ctx context.Context, obj *model.Comment) (string, error) {
	return obj.CreatedAt, nil
}

func (r *commentResolver) Replies(ctx context.Context, obj *model.Comment, first *int, after *string) (*model.CommentsConnection, error) {
	limit := 10
	if first != nil {
		limit = *first
	}
	cursor := ""
	if after != nil {
		cursor = *after
	}

	replies, err := db.GetCommentReplies(r.DB, obj.ID, limit, cursor)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.CommentEdge, len(replies))
	for i, reply := range replies {
		edges[i] = &model.CommentEdge{
			Node: &model.Comment{
				ID:        reply.ID,
				PostID:    reply.PostID,
				ParentID:  reply.ParentID,
				Author:    reply.Author,
				Content:   reply.Content,
				CreatedAt: reply.CreatedAt.Format(time.RFC3339),
			},
			Cursor: reply.ID.String(),
		}
	}

	var startCursor, endCursor *string
	if len(edges) > 0 {
		start := edges[0].Cursor
		end := edges[len(edges)-1].Cursor
		startCursor = &start
		endCursor = &end
	}

	return &model.CommentsConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     len(replies) == limit,
			HasPreviousPage: cursor != "",
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}, nil
}

func (r *commentEdgeResolver) Cursor(ctx context.Context, obj *model.CommentEdge) (string, error) {
	cursor := obj.Node.ID.String()

	return cursor, nil
}

func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (*model.Post, error) {
	post := &model.Post{
		ID:            uuid.New(),
		Title:         input.Title,
		Content:       input.Content,
		Author:        input.Author,
		AllowComments: input.AllowComments,
		CreatedAt:     time.Now().Format(time.RFC3339),
	}

	dbPost := &dbmodel.Post{
		ID:            post.ID,
		Title:         post.Title,
		Content:       post.Content,
		Author:        post.Author,
		AllowComments: post.AllowComments,
		CreatedAt:     time.Now(),
	}

	err := db.CreatePost(r.DB, dbPost)
	if err != nil {
		return nil, err
	}

	return post, nil
}

func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	postID, err := uuid.Parse(input.PostID)
	if err != nil {
		return nil, errors.New("invalid post ID")
	}

	var parentID *uuid.UUID
	if input.ParentID != nil {
		pid, err := uuid.Parse(*input.ParentID)
		if err != nil {
			return nil, errors.New("invalid parent comment ID")
		}
		parentID = &pid
	}

	comment := &model.Comment{
		ID:        uuid.New(),
		PostID:    postID,
		ParentID:  parentID,
		Author:    input.Author,
		Content:   input.Content,
		CreatedAt: time.Now().Format(time.RFC3339),
	}

	dbComment := &dbmodel.Comment{
		ID:        comment.ID,
		PostID:    comment.PostID,
		ParentID:  comment.ParentID,
		Author:    comment.Author,
		Content:   comment.Content,
		CreatedAt: time.Now(),
	}

	err = db.CreateComment(r.DB, dbComment)
	if err != nil {
		return nil, err
	}

	return comment, nil
}

func (r *pageInfoResolver) HasPreviousPage(ctx context.Context, obj *model.PageInfo) (bool, error) {
	panic(fmt.Errorf("not implemented: HasPreviousPage - hasPreviousPage"))
}

func (r *pageInfoResolver) StartCursor(ctx context.Context, obj *model.PageInfo) (*string, error) {
	panic(fmt.Errorf("not implemented: StartCursor - startCursor"))
}

func (r *postResolver) ID(ctx context.Context, obj *model.Post) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

func (r *postResolver) CreatedAt(ctx context.Context, obj *model.Post) (string, error) {
	panic(fmt.Errorf("not implemented: CreatedAt - createdAt"))
}

func (r *postResolver) Comments(ctx context.Context, obj *model.Post, first *int, after *string) (*model.CommentsConnection, error) {
	limit := 10
	if first != nil {
		limit = *first
	}

	cursor := ""
	if after != nil {
		cursor = *after
	}

	comments, err := db.GetComments(r.DB, obj.ID, limit, cursor)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.CommentEdge, len(comments))
	for i, comment := range comments {
		edges[i] = &model.CommentEdge{
			Node: &model.Comment{
				ID:        comment.ID,
				PostID:    comment.PostID,
				ParentID:  comment.ParentID,
				Author:    comment.Author,
				Content:   comment.Content,
				CreatedAt: comment.CreatedAt.Format(time.RFC3339),
			},
			Cursor: comment.ID.String(),
		}
	}

	var startCursor, endCursor *string
	if len(edges) > 0 {
		start := edges[0].Cursor
		end := edges[len(edges)-1].Cursor
		startCursor = &start
		endCursor = &end
	}

	return &model.CommentsConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     len(comments) == limit,
			HasPreviousPage: cursor != "",
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}, nil
}

func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	posts, err := db.GetPosts(r.DB)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Post, len(posts))
	for i, post := range posts {
		result[i] = &model.Post{
			ID:            post.ID,
			Title:         post.Title,
			Content:       post.Content,
			Author:        post.Author,
			AllowComments: post.AllowComments,
			CreatedAt:     post.CreatedAt.Format(time.RFC3339),
		}
	}
	return result, nil
}

func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	postID, err := uuid.Parse(id)
	if err != nil {
		return nil, errors.New("invalid post ID")
	}

	post, err := db.GetPost(r.DB, postID)
	if err != nil {
		return nil, err
	}

	return &model.Post{
		ID:            post.ID,
		Title:         post.Title,
		Content:       post.Content,
		Author:        post.Author,
		AllowComments: post.AllowComments,
		CreatedAt:     post.CreatedAt.Format(time.RFC3339),
	}, nil
}

func (r *queryResolver) Comments(ctx context.Context, postID string, first *int, after *string) (*model.CommentsConnection, error) {
	parsedPostID, err := uuid.Parse(postID)
	if err != nil {
		return nil, errors.New("invalid post ID")
	}

	limit := 10
	if first != nil {
		limit = *first
	}

	cursor := ""
	if after != nil {
		cursor = *after
	}

	comments, err := db.GetComments(r.DB, parsedPostID, limit, cursor)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.CommentEdge, len(comments))
	for i, comment := range comments {
		edges[i] = &model.CommentEdge{
			Node: &model.Comment{
				ID:        comment.ID,
				PostID:    comment.PostID,
				ParentID:  comment.ParentID,
				Author:    comment.Author,
				Content:   comment.Content,
				CreatedAt: comment.CreatedAt.Format(time.RFC3339),
			},
			Cursor: comment.ID.String(),
		}
	}

	var startCursor, endCursor *string
	if len(edges) > 0 {
		start := edges[0].Cursor
		end := edges[len(edges)-1].Cursor
		startCursor = &start
		endCursor = &end
	}

	return &model.CommentsConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     len(comments) == limit,
			HasPreviousPage: cursor != "",
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}, nil
}

func (r *newCommentResolver) PostID(ctx context.Context, obj *model.NewComment, data string) error {
	obj.PostID = data
	return nil
}

func (r *newCommentResolver) ParentID(ctx context.Context, obj *model.NewComment, data *string) error {
	obj.ParentID = data
	return nil
}

func (r *Resolver) Comment() generated.CommentResolver { return &commentResolver{r} }

func (r *Resolver) CommentEdge() generated.CommentEdgeResolver { return &commentEdgeResolver{r} }

func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

func (r *Resolver) PageInfo() generated.PageInfoResolver { return &pageInfoResolver{r} }

func (r *Resolver) Post() generated.PostResolver { return &postResolver{r} }

func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

func (r *Resolver) NewComment() generated.NewCommentResolver { return &newCommentResolver{r} }

type commentResolver struct{ *Resolver }
type commentEdgeResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type pageInfoResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type newCommentResolver struct{ *Resolver }
